{
  function flatten(stuff) {
    return stuff.map(a => a.filter(a => a != null)).map(a => a[0]) ;
  }
}
  Expression "Expression"
      = exp:(Label/Operation/Comment) _ Comment? {
      return exp
      }

  Operation "Operation"
  = exp:Opcode args:(_ ArgumentOrTuple)* {
      return [exp, ...flatten(args)]
      }

  ArgumentOrTuple "Argument or Tuple"
      = aot:(Argument/Tuple/Array) {
      return aot
      }

  Argument "Argument"
      = arg:(Register/Number/String) {
      return arg
      }


   Register "Register"
      = reg:([a-zA-Z][a-zA-Z0-9.]*[a-zA-Z0-9]*) {
      return {
        type: TokenTypes.REGISTER,
            value: text()
            }
      }



  Comment "Comment"
  = "#" .* {
    return null
    }

  Number "Number"
      = sign:("+"/"-")? num:[0-9]+ dot:("." tail:[0-9]+)? {
        /*let n = num.join("");
        if (dot) n += "." + dot[1].join("");
        if (sign) n = sign + n;*/
        return { type: TokenTypes.NUMBER, value: Number(text()) }
      }

  String "String"
   =  '"' string:StringChars* '"' {
     return { type: TokenTypes.STRING, value: string.join("") }
     }

  StringChars
  = [^'"'\n]

  Tuple "Tuple"
      = "("_ args:(_ Argument)* _ ")" {
      return { type: TokenTypes.POINT, value: flatten(args) }
      }



  Array "Array"
      = "["_ args:(_ ArgumentOrTuple)* _ "]" {
      return { type: TokenTypes.ARRAY, value: flatten(args) }
      }

  Opcode "Opcode"
      = [A-Z][A-Z0-9]+ {
      	return { type: TokenTypes.OPCODE, value: text() }
      }

  Label "Label"
      = label:([A-Z0-9]+)":" {
      return [{
        type: TokenTypes.LABEL,
            value: label.join("")
        }]
      }

  _ "whitespace"
    = [	 ]* {
    return null
    }